// generated by go-extpoints -- DO NOT EDIT
package router

import (
	"reflect"
	"runtime"
	"strings"
	"sync"
)

var registry = struct {
	sync.Mutex
	extpoints map[string]*extensionPoint
}{
	extpoints: make(map[string]*extensionPoint),
}

type extensionPoint struct {
	sync.Mutex
	iface      reflect.Type
	components map[string]interface{}
}

func newExtensionPoint(iface interface{}) *extensionPoint {
	ep := &extensionPoint{
		iface:      reflect.TypeOf(iface).Elem(),
		components: make(map[string]interface{}),
	}
	registry.Lock()
	defer registry.Unlock()
	registry.extpoints[ep.iface.Name()] = ep
	return ep
}

func (ep *extensionPoint) lookup(name string) (ext interface{}, ok bool) {
	ep.Lock()
	defer ep.Unlock()
	ext, ok = ep.components[name]
	return
}

func (ep *extensionPoint) all() map[string]interface{} {
	ep.Lock()
	defer ep.Unlock()
	all := make(map[string]interface{})
	for k, v := range ep.components {
		all[k] = v
	}
	return all
}

func (ep *extensionPoint) register(component interface{}, name string) bool {
	ep.Lock()
	defer ep.Unlock()
	if name == "" {
		comType := reflect.TypeOf(component)
		if comType.Kind() == reflect.Func {
			nameParts := strings.Split(runtime.FuncForPC(
				reflect.ValueOf(component).Pointer()).Name(), ".")
			name = nameParts[len(nameParts)-1]
		} else {
			name = comType.Elem().Name()
		}
	}
	_, exists := ep.components[name]
	if exists {
		return false
	}
	ep.components[name] = component
	return true
}

func (ep *extensionPoint) unregister(name string) bool {
	ep.Lock()
	defer ep.Unlock()
	_, exists := ep.components[name]
	if !exists {
		return false
	}
	delete(ep.components, name)
	return true
}

func implements(component interface{}) []string {
	var ifaces []string
	typ := reflect.TypeOf(component)
	for name, ep := range registry.extpoints {
		if ep.iface.Kind() == reflect.Func && typ.AssignableTo(ep.iface) {
			ifaces = append(ifaces, name)
		}
		if ep.iface.Kind() != reflect.Func && typ.Implements(ep.iface) {
			ifaces = append(ifaces, name)
		}
	}
	return ifaces
}

func Register(component interface{}, name string) []string {
	registry.Lock()
	defer registry.Unlock()
	var ifaces []string
	for _, iface := range implements(component) {
		if ok := registry.extpoints[iface].register(component, name); ok {
			ifaces = append(ifaces, iface)
		}
	}
	return ifaces
}

func Unregister(name string) []string {
	registry.Lock()
	defer registry.Unlock()
	var ifaces []string
	for iface, extpoint := range registry.extpoints {
		if ok := extpoint.unregister(name); ok {
			ifaces = append(ifaces, iface)
		}
	}
	return ifaces
}

// HTTPHandler

var HTTPHandlers = &httpHandlerExt{
	newExtensionPoint(new(HTTPHandler)),
}

type httpHandlerExt struct {
	*extensionPoint
}

func (ep *httpHandlerExt) Unregister(name string) bool {
	return ep.unregister(name)
}

func (ep *httpHandlerExt) Register(component HTTPHandler, name string) bool {
	return ep.register(component, name)
}

func (ep *httpHandlerExt) Lookup(name string) (HTTPHandler, bool) {
	ext, ok := ep.lookup(name)
	if !ok {
		return nil, ok
	}
	return ext.(HTTPHandler), ok
}

func (ep *httpHandlerExt) All() map[string]HTTPHandler {
	all := make(map[string]HTTPHandler)
	for k, v := range ep.all() {
		all[k] = v.(HTTPHandler)
	}
	return all
}

func (ep *httpHandlerExt) Names() []string {
	var names []string
	for k := range ep.all() {
		names = append(names, k)
	}
	return names
}

// AdapterFactory

var AdapterFactories = &adapterFactoryExt{
	newExtensionPoint(new(AdapterFactory)),
}

type adapterFactoryExt struct {
	*extensionPoint
}

func (ep *adapterFactoryExt) Unregister(name string) bool {
	return ep.unregister(name)
}

func (ep *adapterFactoryExt) Register(component AdapterFactory, name string) bool {
	return ep.register(component, name)
}

func (ep *adapterFactoryExt) Lookup(name string) (AdapterFactory, bool) {
	ext, ok := ep.lookup(name)
	if !ok {
		return nil, ok
	}
	return ext.(AdapterFactory), ok
}

func (ep *adapterFactoryExt) All() map[string]AdapterFactory {
	all := make(map[string]AdapterFactory)
	for k, v := range ep.all() {
		all[k] = v.(AdapterFactory)
	}
	return all
}

func (ep *adapterFactoryExt) Names() []string {
	var names []string
	for k := range ep.all() {
		names = append(names, k)
	}
	return names
}

// AdapterTransport

var AdapterTransports = &adapterTransportExt{
	newExtensionPoint(new(AdapterTransport)),
}

type adapterTransportExt struct {
	*extensionPoint
}

func (ep *adapterTransportExt) Unregister(name string) bool {
	return ep.unregister(name)
}

func (ep *adapterTransportExt) Register(component AdapterTransport, name string) bool {
	return ep.register(component, name)
}

func (ep *adapterTransportExt) Lookup(name string) (AdapterTransport, bool) {
	ext, ok := ep.lookup(name)
	if !ok {
		return nil, ok
	}
	return ext.(AdapterTransport), ok
}

func (ep *adapterTransportExt) All() map[string]AdapterTransport {
	all := make(map[string]AdapterTransport)
	for k, v := range ep.all() {
		all[k] = v.(AdapterTransport)
	}
	return all
}

func (ep *adapterTransportExt) Names() []string {
	var names []string
	for k := range ep.all() {
		names = append(names, k)
	}
	return names
}

// Job

var Jobs = &jobExt{
	newExtensionPoint(new(Job)),
}

type jobExt struct {
	*extensionPoint
}

func (ep *jobExt) Unregister(name string) bool {
	return ep.unregister(name)
}

func (ep *jobExt) Register(component Job, name string) bool {
	return ep.register(component, name)
}

func (ep *jobExt) Lookup(name string) (Job, bool) {
	ext, ok := ep.lookup(name)
	if !ok {
		return nil, ok
	}
	return ext.(Job), ok
}

func (ep *jobExt) All() map[string]Job {
	all := make(map[string]Job)
	for k, v := range ep.all() {
		all[k] = v.(Job)
	}
	return all
}

func (ep *jobExt) Names() []string {
	var names []string
	for k := range ep.all() {
		names = append(names, k)
	}
	return names
}

// LogRouter

var LogRouters = &logRouterExt{
	newExtensionPoint(new(LogRouter)),
}

type logRouterExt struct {
	*extensionPoint
}

func (ep *logRouterExt) Unregister(name string) bool {
	return ep.unregister(name)
}

func (ep *logRouterExt) Register(component LogRouter, name string) bool {
	return ep.register(component, name)
}

func (ep *logRouterExt) Lookup(name string) (LogRouter, bool) {
	ext, ok := ep.lookup(name)
	if !ok {
		return nil, ok
	}
	return ext.(LogRouter), ok
}

func (ep *logRouterExt) All() map[string]LogRouter {
	all := make(map[string]LogRouter)
	for k, v := range ep.all() {
		all[k] = v.(LogRouter)
	}
	return all
}

func (ep *logRouterExt) Names() []string {
	var names []string
	for k := range ep.all() {
		names = append(names, k)
	}
	return names
}
